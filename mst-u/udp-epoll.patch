--- /usr/src/kernels/linux-3.0.4/include/linux/udp.h	2011-08-30 02:26:30.000000000 +0530
+++ linux-3.0.4/include/linux/udp.h	2013-02-17 11:01:02.238656034 +0530
@@ -29,6 +29,16 @@
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
 #define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
+// udp-epoll support - begin
+struct udp_peer_info {
+    __be32 sip;
+    __be32 dip;
+	__be16	sport;
+	__be16	dport;
+};
+#define UDP_ADD_PEER_INFO	500	/* Add new UDP socket to UDP connected table */
+#define UDP_DEL_PEER_INFO	501	/* Del UDP socket from UDP connected table */
+// udp-epoll support - end
 
 /* UDP encapsulation types */
 #define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
--- /usr/src/kernels/linux-3.0.4/include/net/udp.h	2011-08-30 02:26:30.000000000 +0530
+++ linux-3.0.4/include/net/udp.h	2013-02-17 23:56:34.297951516 +0530
@@ -77,6 +77,25 @@
 	unsigned int		mask;
 	unsigned int		log;
 };
+
+// udp-epoll support - begin
+
+struct udp_conn_info {
+    struct udp_peer_info upi;
+    struct sock *sk;
+    struct hlist_node hnode;
+};
+
+struct udp_conn_table {
+    spinlock_t block;
+    struct hlist_head bhead;
+};
+
+#define D_UDP_CONN_SIZE 1024
+extern struct udp_conn_table udp_conn_table[D_UDP_CONN_SIZE];
+
+// udp-epoll support - end
+
 extern struct udp_table udp_table;
 extern void udp_table_init(struct udp_table *, const char *);
 static inline struct udp_hslot *udp_hashslot(struct udp_table *table,
@@ -164,8 +183,11 @@
 extern void udp_lib_unhash(struct sock *sk);
 extern void udp_lib_rehash(struct sock *sk, u16 new_hash);
 
+void udp4_lib_del_sock_upi(struct sock *sk);
+
 static inline void udp_lib_close(struct sock *sk, long timeout)
 {
+    udp4_lib_del_sock_upi(sk);
 	sk_common_release(sk);
 }
 
--- /usr/src/kernels/linux-3.0.4/net/ipv4/udp.c	2011-08-30 02:26:30.000000000 +0530
+++ linux-3.0.4/net/ipv4/udp.c	2013-02-17 23:57:08.800165584 +0530
@@ -110,6 +110,10 @@
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
 
+static struct kmem_cache *udp_conn_cache;
+struct udp_conn_table udp_conn_table[D_UDP_CONN_SIZE] __read_mostly;
+EXPORT_SYMBOL(udp_conn_table);
+
 long sysctl_udp_mem[3] __read_mostly;
 EXPORT_SYMBOL(sysctl_udp_mem);
 
@@ -1606,6 +1610,99 @@
 	return 0;
 }
 
+struct sock *udp4_lib_lookup_upi(struct udp_peer_info *upi)
+{
+    u32 hbucket = jhash_3words(upi->sip, upi->dip, ((upi->sport << 16) | upi->dport), 0);
+    struct udp_conn_table *uct;
+    struct udp_conn_info *uci;
+    struct sock *sk = NULL;
+    struct hlist_node *hpos;
+
+    hbucket = (hbucket % D_UDP_CONN_SIZE);
+
+    uct = &udp_conn_table[hbucket];
+    spin_lock_bh(&uct->block);
+    hlist_for_each_entry(uci, hpos, &uct->bhead, hnode) {
+        if ((upi->sip == uci->upi.sip) && 
+            (upi->dip == uci->upi.dip) &&
+            (upi->sport == uci->upi.sport) && 
+            (upi->dport == uci->upi.dport)) {
+            sk = uci->sk;
+            sock_hold(sk);
+            break;
+        }
+    }
+    spin_unlock_bh(&uct->block);
+
+    return sk;
+}
+
+void udp4_lib_del_upi(struct udp_peer_info *upi)
+{
+    u32 hbucket = jhash_3words(upi->sip, upi->dip, ((upi->sport << 16) | upi->dport), 0);
+    struct udp_conn_table *uct;
+    struct udp_conn_info *uci;
+    struct hlist_node *hpos;
+    struct hlist_node *htmp;
+
+    hbucket = (hbucket % D_UDP_CONN_SIZE);
+
+    uct = &udp_conn_table[hbucket];
+    spin_lock_bh(&uct->block);
+    hlist_for_each_entry_safe(uci, hpos, htmp, &uct->bhead, hnode) {
+        if ((upi->sip == uci->upi.sip) && 
+            (upi->dip == uci->upi.dip) &&
+            (upi->sport == uci->upi.sport) && 
+            (upi->dport == uci->upi.dport)) {
+            hlist_del(&uci->hnode);
+            kmem_cache_free(udp_conn_cache, uci);
+            break;
+        }
+    }
+    spin_unlock_bh(&uct->block);
+
+    return;
+}
+
+void udp4_lib_del_sock_upi(struct sock *sk)
+{
+    struct inet_sock *inet = inet_sk(sk);
+    struct udp_peer_info upi;
+
+    upi.sip = inet->inet_saddr;
+    upi.dip = inet->inet_daddr;
+    upi.sport = inet->inet_num;
+    upi.dport = inet->inet_dport;
+
+    udp4_lib_del_upi(&upi);
+
+    return;
+}
+
+int udp4_lib_add_upi(struct sock *sk, struct udp_peer_info *upi)
+{
+    u32 hbucket = jhash_3words(upi->sip, upi->dip, ((upi->sport << 16) | upi->dport), 0);
+    struct udp_conn_table *uct;
+    struct udp_conn_info *uci;
+
+    hbucket = (hbucket % D_UDP_CONN_SIZE);
+
+    uct = &udp_conn_table[hbucket];
+
+    uci = kmem_cache_alloc(udp_conn_cache, GFP_KERNEL);
+    WARN_ON(!uci);
+
+    uci->sk = sk;
+    uci->upi = *upi;
+    INIT_HLIST_NODE(&uci->hnode);
+
+    spin_lock_bh(&uct->block);
+    hlist_add_head(&uci->hnode, &uct->bhead);
+    spin_unlock_bh(&uct->block);
+
+    return 0;
+}
+
 /*
  *	All we need to do is get the socket, and then do a checksum.
  */
@@ -1736,10 +1833,86 @@
 	if (optlen < sizeof(int))
 		return -EINVAL;
 
+    switch (optname) {
+        case UDP_ADD_PEER_INFO:
+        {
+            struct udp_peer_info upi;
+            struct inet_sock *inet;
+            int snum;
+            int dnum;
+            struct sock *lsk;
+            int chk_addr_ret;
+            if (sizeof(upi) > optlen) {
+                return -EINVAL;
+            }
+            if (copy_from_user(&upi, optval, sizeof(upi))) {
+                return -EFAULT;
+            }
+            snum = ntohs(upi.sport);
+            dnum = ntohs(upi.dport);
+            if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE)) {
+                return -EACCES;
+            }
+            if (!snum) {
+                return -EINVAL;
+            }
+            if (!dnum) {
+                return -EINVAL;
+            }
+            lsk = udp4_lib_lookup_upi(&upi);
+            if (lsk) {
+                sock_put(lsk);
+                return -EEXIST;
+            }
+			lock_sock(sk);
+            inet = inet_sk(sk);
+            chk_addr_ret = inet_addr_type(sock_net(sk), upi.sip);
+            err = -EADDRNOTAVAIL;
+            if ((!sysctl_ip_nonlocal_bind &&
+                    !(inet->freebind || inet->transparent) &&
+                    chk_addr_ret != RTN_LOCAL &&
+                    chk_addr_ret != RTN_MULTICAST &&
+                    chk_addr_ret != RTN_BROADCAST) ||
+                    (upi.sip == htonl(INADDR_ANY))) {
+                release_sock(sk);
+                return err;
+            }
+            err = 0;
+            inet->inet_rcv_saddr = inet->inet_saddr = upi.sip;
+            inet->inet_daddr = upi.dip;
+            inet->inet_sport = upi.sport;
+            inet->inet_num = upi.sport;
+            inet->inet_dport = upi.dport;
+            if (inet->inet_rcv_saddr)
+                sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+            if (snum)
+                sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
+            sk_dst_reset(sk);
+            // TODO: Add upi to udp_connected_table
+            udp4_lib_add_upi(sk, &upi);
+			release_sock(sk);
+            return err;
+        }
+        case UDP_DEL_PEER_INFO:
+        {
+            struct udp_peer_info upi;
+            if (sizeof(upi) > optlen) {
+                return -EINVAL;
+            }
+            if (copy_from_user(&upi, optval, sizeof(upi))) {
+                return -EFAULT;
+            }
+            lock_sock(sk);
+            udp4_lib_del_upi(&upi);
+			release_sock(sk);
+            return err;
+        }
+    }
+
 	if (get_user(val, (int __user *)optval))
 		return -EFAULT;
 
-	switch (optname) {
+    switch (optname) {
 	case UDP_CORK:
 		if (val != 0) {
 			up->corkflag = 1;
@@ -2209,6 +2382,7 @@
 
 void __init udp_init(void)
 {
+    int i;
 	unsigned long limit;
 
 	udp_table_init(&udp_table, "UDP");
@@ -2220,6 +2394,17 @@
 
 	sysctl_udp_rmem_min = SK_MEM_QUANTUM;
 	sysctl_udp_wmem_min = SK_MEM_QUANTUM;
+
+    udp_conn_cache = kmem_cache_create("udp_conn_cache", sizeof(struct udp_conn_info), 0, SLAB_HWCACHE_ALIGN, NULL);
+
+    if(!udp_conn_cache) {
+        printk(KERN_WARNING "Failed to create udp_conn_cache\n");
+    }
+    
+    for (i = 0; i < D_UDP_CONN_SIZE; i++) {
+        spin_lock_init(&udp_conn_table[i].block);
+        INIT_HLIST_HEAD(&udp_conn_table[i].bhead);
+    }
 }
 
 int udp4_ufo_send_check(struct sk_buff *skb)
